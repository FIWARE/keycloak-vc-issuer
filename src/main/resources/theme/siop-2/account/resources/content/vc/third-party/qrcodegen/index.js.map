{"version":3,"file":"index.js","names":["QrCode","encodeText","text","ecl","segs","qrcodegen","QrSegment","makeSegments","encodeSegments","encodeBinary","data","seg","makeBytes","minVersion","maxVersion","mask","boostEcl","MIN_VERSION","MAX_VERSION","RangeError","version","dataUsedBits","dataCapacityBits","getNumDataCodewords","usedBits","getTotalBits","newEcl","Ecc","MEDIUM","QUARTILE","HIGH","bb","appendBits","mode","modeBits","numChars","numCharCountBits","b","getData","push","assert","length","Math","min","padByte","dataCodewords","forEach","i","constructor","errorCorrectionLevel","msk","size","row","modules","slice","isFunction","drawFunctionPatterns","allCodewords","addEccAndInterleave","drawCodewords","minPenalty","applyMask","drawFormatBits","penalty","getPenaltyScore","getModule","x","y","getModules","setFunctionModule","drawFinderPattern","alignPatPos","getAlignmentPatternPositions","numAlign","j","drawAlignmentPattern","drawVersion","formatBits","rem","bits","getBit","color","a","floor","dy","dx","dist","max","abs","xx","yy","isDark","ver","numBlocks","NUM_ERROR_CORRECTION_BLOCKS","ordinal","blockEccLen","ECC_CODEWORDS_PER_BLOCK","rawCodewords","getNumRawDataModules","numShortBlocks","shortBlockLen","blocks","rsDiv","reedSolomonComputeDivisor","k","dat","ecc","reedSolomonComputeRemainder","concat","result","block","right","vert","upward","invert","Error","runColor","runX","runHistory","PENALTY_N1","finderPenaltyAddHistory","finderPenaltyCountPatterns","PENALTY_N3","finderPenaltyTerminateAndCount","runY","PENALTY_N2","dark","reduce","sum","total","ceil","PENALTY_N4","step","pos","splice","degree","root","reedSolomonMultiply","divisor","map","_","factor","shift","coef","z","n","core","currentRunColor","currentRunLength","pop","unshift","val","len","cond","Mode","BYTE","makeNumeric","digits","isNumeric","parseInt","substring","NUMERIC","makeAlphanumeric","isAlphanumeric","temp","ALPHANUMERIC_CHARSET","indexOf","charAt","ALPHANUMERIC","toUtf8ByteArray","makeEci","assignVal","ECI","NUMERIC_REGEX","test","ALPHANUMERIC_REGEX","bitData","ccbits","Infinity","str","encodeURI","charCodeAt","numBitsCharCount"],"sources":["../../../../../src/app/content/vc/third-party/qrcodegen/index.ts"],"sourcesContent":["/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */\n\n \"use strict\";\n\n\n namespace qrcodegen {\n \n     type bit  = number;\n     type byte = number;\n     type int  = number;\n \n \n     /*---- QR Code symbol class ----*/\n \n     /*\n      * A QR Code symbol, which is a type of two-dimension barcode.\n      * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n      * Instances of this class represent an immutable square grid of dark and light cells.\n      * The class provides static factory functions to create a QR Code from text or binary data.\n      * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n      * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n      *\n      * Ways to create a QR Code object:\n      * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n      * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n      * - Low level: Custom-make the array of data codeword bytes (including\n      *   segment headers and final padding, excluding error correction codewords),\n      *   supply the appropriate version number, and call the QrCode() constructor.\n      * (Note that all ways require supplying the desired error correction level.)\n      */\n     export class QrCode {\n \n         /*-- Static factory functions (high level) --*/\n \n         // Returns a QR Code representing the given Unicode text string at the given error correction level.\n         // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n         // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n         // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n         // ecl argument if it can be done without increasing the version.\n         public static encodeText(text: string, ecl: QrCode.Ecc): QrCode {\n             const segs: Array<QrSegment> = qrcodegen.QrSegment.makeSegments(text);\n             return QrCode.encodeSegments(segs, ecl);\n         }\n \n \n         // Returns a QR Code representing the given binary data at the given error correction level.\n         // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n         // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n         // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n         public static encodeBinary(data: Readonly<Array<byte>>, ecl: QrCode.Ecc): QrCode {\n             const seg: QrSegment = qrcodegen.QrSegment.makeBytes(data);\n             return QrCode.encodeSegments([seg], ecl);\n         }\n \n \n         /*-- Static factory functions (mid level) --*/\n \n         // Returns a QR Code representing the given segments with the given encoding parameters.\n         // The smallest possible QR Code version within the given range is automatically\n         // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n         // may be higher than the ecl argument if it can be done without increasing the\n         // version. The mask number is either between 0 to 7 (inclusive) to force that\n         // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n         // This function allows the user to create a custom sequence of segments that switches\n         // between modes (such as alphanumeric and byte) to encode text in less space.\n         // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n         public static encodeSegments(segs: Readonly<Array<QrSegment>>, ecl: QrCode.Ecc,\n                 minVersion: int = 1, maxVersion: int = 40,\n                 mask: int = -1, boostEcl: boolean = true): QrCode {\n \n             if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION)\n                     || mask < -1 || mask > 7)\n                 throw new RangeError(\"Invalid value\");\n \n             // Find the minimal version number to use\n             let version: int;\n             let dataUsedBits: int;\n             for (version = minVersion; ; version++) {\n                 const dataCapacityBits: int = QrCode.getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n                 const usedBits: number = QrSegment.getTotalBits(segs, version);\n                 if (usedBits <= dataCapacityBits) {\n                     dataUsedBits = usedBits;\n                     break;  // This version number is found to be suitable\n                 }\n                 if (version >= maxVersion)  // All versions in the range could not fit the given data\n                     throw new RangeError(\"Data too long\");\n             }\n \n             // Increase the error correction level while the data still fits in the current version number\n             for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {  // From low to high\n                 if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)\n                     ecl = newEcl;\n             }\n \n             // Concatenate all segments to create the data bit string\n             let bb: Array<bit> = []\n             for (const seg of segs) {\n                 appendBits(seg.mode.modeBits, 4, bb);\n                 appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n                 for (const b of seg.getData())\n                     bb.push(b);\n             }\n             assert(bb.length == dataUsedBits);\n \n             // Add terminator and pad up to a byte if applicable\n             const dataCapacityBits: int = QrCode.getNumDataCodewords(version, ecl) * 8;\n             assert(bb.length <= dataCapacityBits);\n             appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n             appendBits(0, (8 - bb.length % 8) % 8, bb);\n             assert(bb.length % 8 == 0);\n \n             // Pad with alternating bytes until data capacity is reached\n             for (let padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n                 appendBits(padByte, 8, bb);\n \n             // Pack bits into bytes in big endian\n             let dataCodewords: Array<byte> = [];\n             while (dataCodewords.length * 8 < bb.length)\n                 dataCodewords.push(0);\n             bb.forEach((b: bit, i: int) =>\n                 dataCodewords[i >>> 3] |= b << (7 - (i & 7)));\n \n             // Create the QR Code object\n             return new QrCode(version, ecl, dataCodewords, mask);\n         }\n \n \n         /*-- Fields --*/\n \n         // The width and height of this QR Code, measured in modules, between\n         // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n         public readonly size: int;\n \n         // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n         // Even if a QR Code is created with automatic masking requested (mask = -1),\n         // the resulting object still has a mask value between 0 and 7.\n         public readonly mask: int;\n \n         // The modules of this QR Code (false = light, true = dark).\n         // Immutable after constructor finishes. Accessed through getModule().\n         private readonly modules   : Array<Array<boolean>> = [];\n \n         // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n         private readonly isFunction: Array<Array<boolean>> = [];\n \n \n         /*-- Constructor (low level) and fields --*/\n \n         // Creates a new QR Code with the given version number,\n         // error correction level, data codeword bytes, and mask number.\n         // This is a low-level API that most users should not use directly.\n         // A mid-level API is the encodeSegments() function.\n         public constructor(\n                 // The version number of this QR Code, which is between 1 and 40 (inclusive).\n                 // This determines the size of this barcode.\n                 public readonly version: int,\n \n                 // The error correction level used in this QR Code.\n                 public readonly errorCorrectionLevel: QrCode.Ecc,\n \n                 dataCodewords: Readonly<Array<byte>>,\n \n                 msk: int) {\n \n             // Check scalar arguments\n             if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)\n                 throw new RangeError(\"Version value out of range\");\n             if (msk < -1 || msk > 7)\n                 throw new RangeError(\"Mask value out of range\");\n             this.size = version * 4 + 17;\n \n             // Initialize both grids to be size*size arrays of Boolean false\n             let row: Array<boolean> = [];\n             for (let i = 0; i < this.size; i++)\n                 row.push(false);\n             for (let i = 0; i < this.size; i++) {\n                 this.modules   .push(row.slice());  // Initially all light\n                 this.isFunction.push(row.slice());\n             }\n \n             // Compute ECC, draw modules\n             this.drawFunctionPatterns();\n             const allCodewords: Array<byte> = this.addEccAndInterleave(dataCodewords);\n             this.drawCodewords(allCodewords);\n \n             // Do masking\n             if (msk == -1) {  // Automatically choose best mask\n                 let minPenalty: int = 1000000000;\n                 for (let i = 0; i < 8; i++) {\n                     this.applyMask(i);\n                     this.drawFormatBits(i);\n                     const penalty: int = this.getPenaltyScore();\n                     if (penalty < minPenalty) {\n                         msk = i;\n                         minPenalty = penalty;\n                     }\n                     this.applyMask(i);  // Undoes the mask due to XOR\n                 }\n             }\n             assert(0 <= msk && msk <= 7);\n             this.mask = msk;\n             this.applyMask(msk);  // Apply the final choice of mask\n             this.drawFormatBits(msk);  // Overwrite old format bits\n \n             this.isFunction = [];\n         }\n \n \n         /*-- Accessor methods --*/\n \n         // Returns the color of the module (pixel) at the given coordinates, which is false\n         // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n         // If the given coordinates are out of bounds, then false (light) is returned.\n         public getModule(x: int, y: int): boolean {\n             return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n         }\n \n     // Modified to expose modules for easy access\n     public getModules() {\n       return this.modules;\n     }\n \n \n         /*-- Private helper methods for constructor: Drawing function modules --*/\n \n         // Reads this object's version field, and draws and marks all function modules.\n         private drawFunctionPatterns(): void {\n             // Draw horizontal and vertical timing patterns\n             for (let i = 0; i < this.size; i++) {\n                 this.setFunctionModule(6, i, i % 2 == 0);\n                 this.setFunctionModule(i, 6, i % 2 == 0);\n             }\n \n             // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n             this.drawFinderPattern(3, 3);\n             this.drawFinderPattern(this.size - 4, 3);\n             this.drawFinderPattern(3, this.size - 4);\n \n             // Draw numerous alignment patterns\n             const alignPatPos: Array<int> = this.getAlignmentPatternPositions();\n             const numAlign: int = alignPatPos.length;\n             for (let i = 0; i < numAlign; i++) {\n                 for (let j = 0; j < numAlign; j++) {\n                     // Don't draw on the three finder corners\n                     if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n                         this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n                 }\n             }\n \n             // Draw configuration data\n             this.drawFormatBits(0);  // Dummy mask value; overwritten later in the constructor\n             this.drawVersion();\n         }\n \n \n         // Draws two copies of the format bits (with its own error correction code)\n         // based on the given mask and this object's error correction level field.\n         private drawFormatBits(mask: int): void {\n             // Calculate error correction code and pack bits\n             const data: int = this.errorCorrectionLevel.formatBits << 3 | mask;  // errCorrLvl is uint2, mask is uint3\n             let rem: int = data;\n             for (let i = 0; i < 10; i++)\n                 rem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n             const bits = (data << 10 | rem) ^ 0x5412;  // uint15\n             assert(bits >>> 15 == 0);\n \n             // Draw first copy\n             for (let i = 0; i <= 5; i++)\n                 this.setFunctionModule(8, i, getBit(bits, i));\n             this.setFunctionModule(8, 7, getBit(bits, 6));\n             this.setFunctionModule(8, 8, getBit(bits, 7));\n             this.setFunctionModule(7, 8, getBit(bits, 8));\n             for (let i = 9; i < 15; i++)\n                 this.setFunctionModule(14 - i, 8, getBit(bits, i));\n \n             // Draw second copy\n             for (let i = 0; i < 8; i++)\n                 this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n             for (let i = 8; i < 15; i++)\n                 this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n             this.setFunctionModule(8, this.size - 8, true);  // Always dark\n         }\n \n \n         // Draws two copies of the version bits (with its own error correction code),\n         // based on this object's version field, iff 7 <= version <= 40.\n         private drawVersion(): void {\n             if (this.version < 7)\n                 return;\n \n             // Calculate error correction code and pack bits\n             let rem: int = this.version;  // version is uint6, in the range [7, 40]\n             for (let i = 0; i < 12; i++)\n                 rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);\n             const bits: int = this.version << 12 | rem;  // uint18\n             assert(bits >>> 18 == 0);\n \n             // Draw two copies\n             for (let i = 0; i < 18; i++) {\n                 const color: boolean = getBit(bits, i);\n                 const a: int = this.size - 11 + i % 3;\n                 const b: int = Math.floor(i / 3);\n                 this.setFunctionModule(a, b, color);\n                 this.setFunctionModule(b, a, color);\n             }\n         }\n \n \n         // Draws a 9*9 finder pattern including the border separator,\n         // with the center module at (x, y). Modules can be out of bounds.\n         private drawFinderPattern(x: int, y: int): void {\n             for (let dy = -4; dy <= 4; dy++) {\n                 for (let dx = -4; dx <= 4; dx++) {\n                     const dist: int = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm\n                     const xx: int = x + dx;\n                     const yy: int = y + dy;\n                     if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)\n                         this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n                 }\n             }\n         }\n \n \n         // Draws a 5*5 alignment pattern, with the center module\n         // at (x, y). All modules must be in bounds.\n         private drawAlignmentPattern(x: int, y: int): void {\n             for (let dy = -2; dy <= 2; dy++) {\n                 for (let dx = -2; dx <= 2; dx++)\n                     this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n             }\n         }\n \n \n         // Sets the color of a module and marks it as a function module.\n         // Only used by the constructor. Coordinates must be in bounds.\n         private setFunctionModule(x: int, y: int, isDark: boolean): void {\n             this.modules[y][x] = isDark;\n             this.isFunction[y][x] = true;\n         }\n \n \n         /*-- Private helper methods for constructor: Codewords and masking --*/\n \n         // Returns a new byte string representing the given data with the appropriate error correction\n         // codewords appended to it, based on this object's version and error correction level.\n         private addEccAndInterleave(data: Readonly<Array<byte>>): Array<byte> {\n             const ver: int = this.version;\n             const ecl: QrCode.Ecc = this.errorCorrectionLevel;\n             if (data.length != QrCode.getNumDataCodewords(ver, ecl))\n                 throw new RangeError(\"Invalid argument\");\n \n             // Calculate parameter numbers\n             const numBlocks: int = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n             const blockEccLen: int = QrCode.ECC_CODEWORDS_PER_BLOCK  [ecl.ordinal][ver];\n             const rawCodewords: int = Math.floor(QrCode.getNumRawDataModules(ver) / 8);\n             const numShortBlocks: int = numBlocks - rawCodewords % numBlocks;\n             const shortBlockLen: int = Math.floor(rawCodewords / numBlocks);\n \n             // Split data into blocks and append ECC to each block\n             let blocks: Array<Array<byte>> = [];\n             const rsDiv: Array<byte> = QrCode.reedSolomonComputeDivisor(blockEccLen);\n             for (let i = 0, k = 0; i < numBlocks; i++) {\n                 let dat: Array<byte> = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n                 k += dat.length;\n                 const ecc: Array<byte> = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n                 if (i < numShortBlocks)\n                     dat.push(0);\n                 blocks.push(dat.concat(ecc));\n             }\n \n             // Interleave (not concatenate) the bytes from every block into a single sequence\n             let result: Array<byte> = [];\n             for (let i = 0; i < blocks[0].length; i++) {\n                 blocks.forEach((block, j) => {\n                     // Skip the padding byte in short blocks\n                     if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n                         result.push(block[i]);\n                 });\n             }\n             assert(result.length == rawCodewords);\n             return result;\n         }\n \n \n         // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n         // data area of this QR Code. Function modules need to be marked off before this is called.\n         private drawCodewords(data: Readonly<Array<byte>>): void {\n             if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))\n                 throw new RangeError(\"Invalid argument\");\n             let i: int = 0;  // Bit index into the data\n             // Do the funny zigzag scan\n             for (let right = this.size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n                 if (right == 6)\n                     right = 5;\n                 for (let vert = 0; vert < this.size; vert++) {  // Vertical counter\n                     for (let j = 0; j < 2; j++) {\n                         const x: int = right - j;  // Actual x coordinate\n                         const upward: boolean = ((right + 1) & 2) == 0;\n                         const y: int = upward ? this.size - 1 - vert : vert;  // Actual y coordinate\n                         if (!this.isFunction[y][x] && i < data.length * 8) {\n                             this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                             i++;\n                         }\n                         // If this QR Code has any remainder bits (0 to 7), they were assigned as\n                         // 0/false/light by the constructor and are left unchanged by this method\n                     }\n                 }\n             }\n             assert(i == data.length * 8);\n         }\n \n \n         // XORs the codeword modules in this QR Code with the given mask pattern.\n         // The function modules must be marked and the codeword bits must be drawn\n         // before masking. Due to the arithmetic of XOR, calling applyMask() with\n         // the same mask value a second time will undo the mask. A final well-formed\n         // QR Code needs exactly one (not zero, two, etc.) mask applied.\n         private applyMask(mask: int): void {\n             if (mask < 0 || mask > 7)\n                 throw new RangeError(\"Mask value out of range\");\n             for (let y = 0; y < this.size; y++) {\n                 for (let x = 0; x < this.size; x++) {\n                     let invert: boolean;\n                     switch (mask) {\n                         case 0:  invert = (x + y) % 2 == 0;                                  break;\n                         case 1:  invert = y % 2 == 0;                                        break;\n                         case 2:  invert = x % 3 == 0;                                        break;\n                         case 3:  invert = (x + y) % 3 == 0;                                  break;\n                         case 4:  invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;  break;\n                         case 5:  invert = x * y % 2 + x * y % 3 == 0;                        break;\n                         case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;                  break;\n                         case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;                break;\n                         default:  throw new Error(\"Unreachable\");\n                     }\n                     if (!this.isFunction[y][x] && invert)\n                         this.modules[y][x] = !this.modules[y][x];\n                 }\n             }\n         }\n \n \n         // Calculates and returns the penalty score based on state of this QR Code's current modules.\n         // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n         private getPenaltyScore(): int {\n             let result: int = 0;\n \n             // Adjacent modules in row having same color, and finder-like patterns\n             for (let y = 0; y < this.size; y++) {\n                 let runColor = false;\n                 let runX = 0;\n                 let runHistory = [0,0,0,0,0,0,0];\n                 for (let x = 0; x < this.size; x++) {\n                     if (this.modules[y][x] == runColor) {\n                         runX++;\n                         if (runX == 5)\n                             result += QrCode.PENALTY_N1;\n                         else if (runX > 5)\n                             result++;\n                     } else {\n                         this.finderPenaltyAddHistory(runX, runHistory);\n                         if (!runColor)\n                             result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n                         runColor = this.modules[y][x];\n                         runX = 1;\n                     }\n                 }\n                 result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;\n             }\n             // Adjacent modules in column having same color, and finder-like patterns\n             for (let x = 0; x < this.size; x++) {\n                 let runColor = false;\n                 let runY = 0;\n                 let runHistory = [0,0,0,0,0,0,0];\n                 for (let y = 0; y < this.size; y++) {\n                     if (this.modules[y][x] == runColor) {\n                         runY++;\n                         if (runY == 5)\n                             result += QrCode.PENALTY_N1;\n                         else if (runY > 5)\n                             result++;\n                     } else {\n                         this.finderPenaltyAddHistory(runY, runHistory);\n                         if (!runColor)\n                             result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n                         runColor = this.modules[y][x];\n                         runY = 1;\n                     }\n                 }\n                 result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3;\n             }\n \n             // 2*2 blocks of modules having same color\n             for (let y = 0; y < this.size - 1; y++) {\n                 for (let x = 0; x < this.size - 1; x++) {\n                     const color: boolean = this.modules[y][x];\n                     if (  color == this.modules[y][x + 1] &&\n                           color == this.modules[y + 1][x] &&\n                           color == this.modules[y + 1][x + 1])\n                         result += QrCode.PENALTY_N2;\n                 }\n             }\n \n             // Balance of dark and light modules\n             let dark: int = 0;\n             for (const row of this.modules)\n                 dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n             const total: int = this.size * this.size;  // Note that size is odd, so dark/total != 1/2\n             // Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n             const k: int = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n             assert(0 <= k && k <= 9);\n             result += k * QrCode.PENALTY_N4;\n             assert(0 <= result && result <= 2568888);  // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n             return result;\n         }\n \n \n         /*-- Private helper functions --*/\n \n         // Returns an ascending list of positions of alignment patterns for this version number.\n         // Each position is in the range [0,177), and are used on both the x and y axes.\n         // This could be implemented as lookup table of 40 variable-length lists of integers.\n         private getAlignmentPatternPositions(): Array<int> {\n             if (this.version == 1)\n                 return [];\n             else {\n                 const numAlign: int = Math.floor(this.version / 7) + 2;\n                 const step: int = (this.version == 32) ? 26 :\n                     Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n                 let result: Array<int> = [6];\n                 for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n                     result.splice(1, 0, pos);\n                 return result;\n             }\n         }\n \n \n         // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n         // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n         // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n         private static getNumRawDataModules(ver: int): int {\n             if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)\n                 throw new RangeError(\"Version number out of range\");\n             let result: int = (16 * ver + 128) * ver + 64;\n             if (ver >= 2) {\n                 const numAlign: int = Math.floor(ver / 7) + 2;\n                 result -= (25 * numAlign - 10) * numAlign - 55;\n                 if (ver >= 7)\n                     result -= 36;\n             }\n             assert(208 <= result && result <= 29648);\n             return result;\n         }\n \n \n         // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n         // QR Code of the given version number and error correction level, with remainder bits discarded.\n         // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n         private static getNumDataCodewords(ver: int, ecl: QrCode.Ecc): int {\n             return Math.floor(QrCode.getNumRawDataModules(ver) / 8) -\n                 QrCode.ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal][ver] *\n                 QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n         }\n \n \n         // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n         // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n         private static reedSolomonComputeDivisor(degree: int): Array<byte> {\n             if (degree < 1 || degree > 255)\n                 throw new RangeError(\"Degree out of range\");\n             // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n             // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].\n             let result: Array<byte> = [];\n             for (let i = 0; i < degree - 1; i++)\n                 result.push(0);\n             result.push(1);  // Start off with the monomial x^0\n \n             // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n             // and drop the highest monomial term which is always 1x^degree.\n             // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n             let root = 1;\n             for (let i = 0; i < degree; i++) {\n                 // Multiply the current product by (x - r^i)\n                 for (let j = 0; j < result.length; j++) {\n                     result[j] = QrCode.reedSolomonMultiply(result[j], root);\n                     if (j + 1 < result.length)\n                         result[j] ^= result[j + 1];\n                 }\n                 root = QrCode.reedSolomonMultiply(root, 0x02);\n             }\n             return result;\n         }\n \n \n         // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n         private static reedSolomonComputeRemainder(data: Readonly<Array<byte>>, divisor: Readonly<Array<byte>>): Array<byte> {\n             let result: Array<byte> = divisor.map(_ => 0);\n             for (const b of data) {  // Polynomial division\n                 const factor: byte = b ^ (result.shift() as byte);\n                 result.push(0);\n                 divisor.forEach((coef, i) =>\n                     result[i] ^= QrCode.reedSolomonMultiply(coef, factor));\n             }\n             return result;\n         }\n \n \n         // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n         // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n         private static reedSolomonMultiply(x: byte, y: byte): byte {\n             if (x >>> 8 != 0 || y >>> 8 != 0)\n                 throw new RangeError(\"Byte out of range\");\n             // Russian peasant multiplication\n             let z: int = 0;\n             for (let i = 7; i >= 0; i--) {\n                 z = (z << 1) ^ ((z >>> 7) * 0x11D);\n                 z ^= ((y >>> i) & 1) * x;\n             }\n             assert(z >>> 8 == 0);\n             return z as byte;\n         }\n \n \n         // Can only be called immediately after a light run is added, and\n         // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n         private finderPenaltyCountPatterns(runHistory: Readonly<Array<int>>): int {\n             const n: int = runHistory[1];\n             assert(n <= this.size * 3);\n             const core: boolean = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n             return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n                  + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n         }\n \n \n         // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n         private finderPenaltyTerminateAndCount(currentRunColor: boolean, currentRunLength: int, runHistory: Array<int>): int {\n             if (currentRunColor) {  // Terminate dark run\n                 this.finderPenaltyAddHistory(currentRunLength, runHistory);\n                 currentRunLength = 0;\n             }\n             currentRunLength += this.size;  // Add light border to final run\n             this.finderPenaltyAddHistory(currentRunLength, runHistory);\n             return this.finderPenaltyCountPatterns(runHistory);\n         }\n \n \n         // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n         private finderPenaltyAddHistory(currentRunLength: int, runHistory: Array<int>): void {\n             if (runHistory[0] == 0)\n                 currentRunLength += this.size;  // Add light border to initial run\n             runHistory.pop();\n             runHistory.unshift(currentRunLength);\n         }\n \n \n         /*-- Constants and tables --*/\n \n         // The minimum version number supported in the QR Code Model 2 standard.\n         public static readonly MIN_VERSION: int =  1;\n         // The maximum version number supported in the QR Code Model 2 standard.\n         public static readonly MAX_VERSION: int = 40;\n \n         // For use in getPenaltyScore(), when evaluating which mask is best.\n         private static readonly PENALTY_N1: int =  3;\n         private static readonly PENALTY_N2: int =  3;\n         private static readonly PENALTY_N3: int = 40;\n         private static readonly PENALTY_N4: int = 10;\n \n         private static readonly ECC_CODEWORDS_PER_BLOCK: Array<Array<int>> = [\n             // Version: (note that index 0 is for padding, and is set to an illegal value)\n             //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n             [-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Low\n             [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],  // Medium\n             [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Quartile\n             [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // High\n         ];\n \n         private static readonly NUM_ERROR_CORRECTION_BLOCKS: Array<Array<int>> = [\n             // Version: (note that index 0 is for padding, and is set to an illegal value)\n             //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n             [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],  // Low\n             [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],  // Medium\n             [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],  // Quartile\n             [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],  // High\n         ];\n \n     }\n \n \n     // Appends the given number of low-order bits of the given value\n     // to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\n     function appendBits(val: int, len: int, bb: Array<bit>): void {\n         if (len < 0 || len > 31 || val >>> len != 0)\n             throw new RangeError(\"Value out of range\");\n         for (let i = len - 1; i >= 0; i--)  // Append bit by bit\n             bb.push((val >>> i) & 1);\n     }\n \n \n     // Returns true iff the i'th bit of x is set to 1.\n     function getBit(x: int, i: int): boolean {\n         return ((x >>> i) & 1) != 0;\n     }\n \n \n     // Throws an exception if the given condition is false.\n     function assert(cond: boolean): void {\n         if (!cond)\n             throw new Error(\"Assertion error\");\n     }\n \n \n \n     /*---- Data segment class ----*/\n \n     /*\n      * A segment of character/binary/control data in a QR Code symbol.\n      * Instances of this class are immutable.\n      * The mid-level way to create a segment is to take the payload data\n      * and call a static factory function such as QrSegment.makeNumeric().\n      * The low-level way to create a segment is to custom-make the bit buffer\n      * and call the QrSegment() constructor with appropriate values.\n      * This segment class imposes no length restrictions, but QR Codes have restrictions.\n      * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n      * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n      */\n     export class QrSegment {\n \n         /*-- Static factory functions (mid level) --*/\n \n         // Returns a segment representing the given binary data encoded in\n         // byte mode. All input byte arrays are acceptable. Any text string\n         // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n         public static makeBytes(data: Readonly<Array<byte>>): QrSegment {\n             let bb: Array<bit> = []\n             for (const b of data)\n                 appendBits(b, 8, bb);\n             return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);\n         }\n \n \n         // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n         public static makeNumeric(digits: string): QrSegment {\n             if (!QrSegment.isNumeric(digits))\n                 throw new RangeError(\"String contains non-numeric characters\");\n             let bb: Array<bit> = []\n             for (let i = 0; i < digits.length; ) {  // Consume up to 3 digits per iteration\n                 const n: int = Math.min(digits.length - i, 3);\n                 appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n                 i += n;\n             }\n             return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);\n         }\n \n \n         // Returns a segment representing the given text string encoded in alphanumeric mode.\n         // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n         // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n         public static makeAlphanumeric(text: string): QrSegment {\n             if (!QrSegment.isAlphanumeric(text))\n                 throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n             let bb: Array<bit> = []\n             let i: int;\n             for (i = 0; i + 2 <= text.length; i += 2) {  // Process groups of 2\n                 let temp: int = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n                 temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n                 appendBits(temp, 11, bb);\n             }\n             if (i < text.length)  // 1 character remaining\n                 appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n             return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n         }\n \n \n         // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n         // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n         public static makeSegments(text: string): Array<QrSegment> {\n             // Select the most efficient segment encoding automatically\n             if (text == \"\")\n                 return [];\n             else if (QrSegment.isNumeric(text))\n                 return [QrSegment.makeNumeric(text)];\n             else if (QrSegment.isAlphanumeric(text))\n                 return [QrSegment.makeAlphanumeric(text)];\n             else\n                 return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n         }\n \n \n         // Returns a segment representing an Extended Channel Interpretation\n         // (ECI) designator with the given assignment value.\n         public static makeEci(assignVal: int): QrSegment {\n             let bb: Array<bit> = []\n             if (assignVal < 0)\n                 throw new RangeError(\"ECI assignment value out of range\");\n             else if (assignVal < (1 << 7))\n                 appendBits(assignVal, 8, bb);\n             else if (assignVal < (1 << 14)) {\n                 appendBits(0b10, 2, bb);\n                 appendBits(assignVal, 14, bb);\n             } else if (assignVal < 1000000) {\n                 appendBits(0b110, 3, bb);\n                 appendBits(assignVal, 21, bb);\n             } else\n                 throw new RangeError(\"ECI assignment value out of range\");\n             return new QrSegment(QrSegment.Mode.ECI, 0, bb);\n         }\n \n \n         // Tests whether the given string can be encoded as a segment in numeric mode.\n         // A string is encodable iff each character is in the range 0 to 9.\n         public static isNumeric(text: string): boolean {\n             return QrSegment.NUMERIC_REGEX.test(text);\n         }\n \n \n         // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n         // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n         // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n         public static isAlphanumeric(text: string): boolean {\n             return QrSegment.ALPHANUMERIC_REGEX.test(text);\n         }\n \n \n         /*-- Constructor (low level) and fields --*/\n \n         // Creates a new QR Code segment with the given attributes and data.\n         // The character count (numChars) must agree with the mode and the bit buffer length,\n         // but the constraint isn't checked. The given bit buffer is cloned and stored.\n         public constructor(\n                 // The mode indicator of this segment.\n                 public readonly mode: QrSegment.Mode,\n \n                 // The length of this segment's unencoded data. Measured in characters for\n                 // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n                 // Always zero or positive. Not the same as the data's bit length.\n                 public readonly numChars: int,\n \n                 // The data bits of this segment. Accessed through getData().\n                 private readonly bitData: Array<bit>) {\n \n             if (numChars < 0)\n                 throw new RangeError(\"Invalid argument\");\n             this.bitData = bitData.slice();  // Make defensive copy\n         }\n \n \n         /*-- Methods --*/\n \n         // Returns a new copy of the data bits of this segment.\n         public getData(): Array<bit> {\n             return this.bitData.slice();  // Make defensive copy\n         }\n \n \n         // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n         // the given version. The result is infinity if a segment has too many characters to fit its length field.\n         public static getTotalBits(segs: Readonly<Array<QrSegment>>, version: int): number {\n             let result: number = 0;\n             for (const seg of segs) {\n                 const ccbits: int = seg.mode.numCharCountBits(version);\n                 if (seg.numChars >= (1 << ccbits))\n                     return Infinity;  // The segment's length doesn't fit the field's bit width\n                 result += 4 + ccbits + seg.bitData.length;\n             }\n             return result;\n         }\n \n \n         // Returns a new array of bytes representing the given string encoded in UTF-8.\n         private static toUtf8ByteArray(str: string): Array<byte> {\n             str = encodeURI(str);\n             let result: Array<byte> = [];\n             for (let i = 0; i < str.length; i++) {\n                 if (str.charAt(i) != \"%\")\n                     result.push(str.charCodeAt(i));\n                 else {\n                     result.push(parseInt(str.substring(i + 1, i + 3), 16));\n                     i += 2;\n                 }\n             }\n             return result;\n         }\n \n \n         /*-- Constants --*/\n \n         // Describes precisely all strings that are encodable in numeric mode.\n         private static readonly NUMERIC_REGEX: RegExp = /^[0-9]*$/;\n \n         // Describes precisely all strings that are encodable in alphanumeric mode.\n         private static readonly ALPHANUMERIC_REGEX: RegExp = /^[A-Z0-9 $%*+.\\/:-]*$/;\n \n         // The set of all legal characters in alphanumeric mode,\n         // where each character value maps to the index in the string.\n         private static readonly ALPHANUMERIC_CHARSET: string = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n \n     }\n \n }\n \n \n \n /*---- Public helper enumeration ----*/\n \n namespace qrcodegen.QrCode {\n \n     type int = number;\n \n \n     /*\n      * The error correction level in a QR Code symbol. Immutable.\n      */\n     export class Ecc {\n \n         /*-- Constants --*/\n \n         public static readonly LOW      = new Ecc(0, 1);  // The QR Code can tolerate about  7% erroneous codewords\n         public static readonly MEDIUM   = new Ecc(1, 0);  // The QR Code can tolerate about 15% erroneous codewords\n         public static readonly QUARTILE = new Ecc(2, 3);  // The QR Code can tolerate about 25% erroneous codewords\n         public static readonly HIGH     = new Ecc(3, 2);  // The QR Code can tolerate about 30% erroneous codewords\n \n \n         /*-- Constructor and fields --*/\n \n         private constructor(\n             // In the range 0 to 3 (unsigned 2-bit integer).\n             public readonly ordinal: int,\n             // (Package-private) In the range 0 to 3 (unsigned 2-bit integer).\n             public readonly formatBits: int) {}\n \n     }\n }\n \n \n \n /*---- Public helper enumeration ----*/\n \n namespace qrcodegen.QrSegment {\n \n     type int = number;\n \n \n     /*\n      * Describes how a segment's data bits are interpreted. Immutable.\n      */\n     export class Mode {\n \n         /*-- Constants --*/\n \n         public static readonly NUMERIC      = new Mode(0x1, [10, 12, 14]);\n         public static readonly ALPHANUMERIC = new Mode(0x2, [ 9, 11, 13]);\n         public static readonly BYTE         = new Mode(0x4, [ 8, 16, 16]);\n         public static readonly KANJI        = new Mode(0x8, [ 8, 10, 12]);\n         public static readonly ECI          = new Mode(0x7, [ 0,  0,  0]);\n \n \n         /*-- Constructor and fields --*/\n \n         private constructor(\n             // The mode indicator bits, which is a uint4 value (range 0 to 15).\n             public readonly modeBits: int,\n             // Number of character count bits for three different version ranges.\n             private readonly numBitsCharCount: [int,int,int]) {}\n \n \n         /*-- Method --*/\n \n         // (Package-private) Returns the bit width of the character count field for a segment in\n         // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n         public numCharCountBits(ver: int): int {\n             return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n         }\n \n     }\n }\n \n // Modification to export for actual use\n export default qrcodegen\n "],"mappings":"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AE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAAG;EACvK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAAG;EACvK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAAG;EACvK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE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"}