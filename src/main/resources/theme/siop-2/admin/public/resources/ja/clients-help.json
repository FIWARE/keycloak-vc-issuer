{
  "clientType": "「OpenID Connect」により、クライアントは認可サーバーによって実行される認証に基づいてエンドユーザーのアイデンティティーを検証できます。「SAML」は、クロスドメインのシングル・サインオン（SSO）を含むWebベースの認証および認可のシナリオを可能にし、アサーションを含むセキュリティー・トークンを使用して情報を渡します。",
  "serviceAccount": "このクライアントをKeycloakで認証し、このクライアント専用のアクセストークンの取得ができるようになります。OAuth2の仕様における「クライアント・クレデンシャル・グラント」のサポートを有効にします。",
  "authorization": "きめ細かい認可のサポートを有効/無効にします。",
  "directAccess": "ダイレクト・アクセス・グラントのサポートを有効にします。これは、アクセストークンの取得のためにKeycloakサーバーとユーザーのユーザー名/パスワードで直接アクセスを行います。OAuth2の仕様における「リソース・オーナー・パスワード・クレデンシャル・グラント」のサポートを有効にします。",
  "standardFlow": "OpenID Connectの標準的な、認可コードによるリダイレクト・ベースの認証を有効にします。OpenID ConnectまたはOAuth2の仕様における「認可コードフロー」のサポートを有効にします。",
  "implicitFlow": "OpenID Connectの認可コードなしのリダイレクト・ベース認証のサポートを有効にします。OpenID ConnectまたはOAuth2の仕様における「インプリシット・フロー」のサポートを有効にします。",
  "rootURL": "相対URLに追加するルートURLを設定します。",
  "validRedirectURIs": "ログインまたはログインの成功後にブラウザーがリダイレクト可能とする、有効なURIパターンを設定します。「http://example.com/*」のような単純なワイルドカードが使用可能です。相対パス、つまり「/my/relative/path/*」も指定可能です。相対パスはクライアントのルートURLを基準とします。または、未指定の場合は認証サーバーのルートURLが使用されます。SAMLでは、ログイン・リクエストに埋め込まれたコンシューマー・サービスのURLに依存している場合は、有効なURIパターンを設定する必要があります。",
  "nameIdFormat": "サブジェクトに使用するName IDフォーマットを設定します。",
  "alwaysDisplayInConsole": "ユーザーのアクティブなセッションがない場合でも、このクライアントを常にアカウント・コンソールに一覧表示します。",
  "forceNameIdFormat": "要求されたNameIDサブジェクト・フォーマットを無視し、管理コンソールで設定された物を使用します。",
  "forcePostBinding": "レスポンスに常にPOSTバインディングを使用します。",
  "includeAuthnStatement": "認証方式とタイムスタンプを含めたステートメントをログイン・レスポンスに含めるべきか設定します。",
  "includeOneTimeUseCondition": "OneTimeUse条件をログイン・レスポンスに含めるべきか設定します。",
  "optimizeLookup": "Keycloakアダプターによって保護されたSPのREDIRECTバインディングでSAMLドキュメントに署名する際、署名鍵のIDを<Extensions>要素のSAMLプロトコルメッセージに含める必要があるかどうかを設定します。これにより、検証のために既知のすべてのキーを試行する代わりに単一のキーを使用するため、署名の検証が最適化されます。",
  "signDocuments": "SAMLドキュメントをレルムで署名すべきか設定します。",
  "signAssertions": "SAMLドキュメント内のアサーションを署名すべきか設定します。もしドキュメントが既に署名済みの場合は、この設定は不要です。",
  "signatureAlgorithm": "ドキュメントの署名に使用する署名アルゴリズムです。",
  "signatureKeyName": "署名されたSAML文書には、KeyName要素の署名鍵の識別情報が含まれています。Keycloak / RH-SSOカウンター・パーティーの場合は、KEY_IDを使用し、MS AD FSの場合はCERT_SUBJECTを使用します。他のオプションが動作しない場合はNONEをチェックして使用します。",
  "canonicalization": "XML署名の正規化方式（Canonicalization Method）を設定します。",
  "webOrigins": "許可されるCORSオリジンを設定します。有効なリダイレクトURIのすべてのオリジンを許可するには「+」を追加してください。ただし、これには「*」ワイルドカードは含まれません。すべてのオリジンを許可するには、明示的に「*」を追加してください。",
  "homeURL": "認証サーバーがクライアントへのリダイレクトまたは戻るリンクを必要とする際に使用するデフォルトURLを設定します。",
  "adminURL": "クライアントの管理インターフェイスのURLを設定します。クライアントがアダプターのREST APIをサポートしている場合に設定してください。このREST APIにより、認証サーバーは無効化ポリシーや他の管理タスクをプッシュすることができます。通常、クライアントのベースURLを設定します。",
  "client": "認可リクエストを作成するクライアントを選択してください。提供されない場合は、認可リクエストは今いるページのクライアントで行われることになります。",
  "clientId": "URIとトークンで参照されるIDを指定します。例えば「my-client」です。SAMLにおいては期待されるAuthnRequestのIssuerの値になります。",
  "selectUser": "サーバーからパーミッションを検索するためにIDが使用されるユーザーを選択します。",
  "roles": "選択されたユーザーに関連付けたいロールを選択してください。",
  "contextualAttributes": "実行環境や実行コンテキストによって提供される任意の属性を設定します。",
  "applyToResourceType": "このパーミッションが、特定タイプの全リソースに適用されるべきかどうかを指定します。この場合、パーミッションは特定リソースタイプの全インスタンスに対して評価されます。",
  "resources": "このパーミッションが適用されるリソース・インスタンスを指定します。",
  "scopesSelect": "このパーミッションは1つまたは複数のスコープに適用されるように指定してください。",
  "clientName": "クライアントの表示名を指定します。例えば、「My Client」です。ローカライズ用のキーもサポートしています。例: ${my_client}",
  "description": "クライアントの説明を指定します。例えば「タイムシート用のクライアント」です。ローカライズ用のキーもサポートしています。例: ${my_client_description}",
  "loginTheme": "ログイン、OTP、グラント、登録、およびパスワード忘れに使用するページのテーマを選択します。",
  "encryptAssertions": "SAMLアサーションをクライアントの公開鍵でAESを使い暗号化すべきか設定します。",
  "clientSignature": "クライアントがSAMLリクエストとレスポンスを署名するか、そしてそれらを検証すべきどうかか設定します。",
  "expiration": "トークンの有効期間を指定します。",
  "count": "このトークンを利用してクライアントをいくつ作成可能か指定します。",
  "client-authenticator-type": "Keycloakサーバーに対してこのクライアントの認証に使用するクライアント認証方式を設定します。",
  "registration-access-token": "登録用アクセストークンにより、クライアントはクライアント登録サービスにアクセスできます。",
  "effectiveProtocolMappers": "すべてのデフォルトのクライアント・スコープと選択されたオプションのスコープが含まれます。クライアントに発行されたアクセストークンを生成するときに、すべてのクライアント・スコープのすべてのプロトコル・マッパーとロールスコープのマッピングが使用されます",
  "scopeParameter": "このスコープ・パラメーターの値をコピー/ペーストし、このクライアント・アダプターから送信された最初のOpenID Connect認証リクエストで使用できます。このクライアントに発行されたトークンを生成するときは、デフォルトのクライアント・スコープと選択されたオプションのクライアント・スコープが使用されます",
  "user": "必要に応じて、サンプルのアクセストークンを生成するユーザーを選択します。ユーザーを選択しないと、評価中にサンプルのアクセストークンは生成されません",
  "nodeReRegistrationTimeout": "登録されたクライアントをクラスターノードへ再登録する際の最大時間間隔を設定します。クラスターノードがこの時間内にKeycloakに再登録リクエストを送信しない場合は、Keycloakから登録解除されます。",
  "accessTokenSignatureAlgorithm": "アクセストークンの署名に使用されるJWAアルゴリズム。",
  "idTokenSignatureAlgorithm": "IDトークンの署名に使用されるJWAアルゴリズム。",
  "idTokenEncryptionKeyManagementAlgorithm": "IDトークンの暗号化鍵の管理に使用されるJWAアルゴリズム。このオプションは、暗号化されたIDトークンが必要な場合に必須です。空のままにすると、IDトークンは署名されますが、暗号化されません。",
  "idTokenEncryptionContentEncryptionAlgorithm": "IDトークンの暗号化の際に、コンテンツの暗号化に使用されるJWAアルゴリズム。このオプションは、暗号化されたIDトークンが必要な場合にのみ必須です。空のままにすると、IDトークンは署名されますが、暗号化されません。",
  "userInfoSignedResponseAlgorithm": "署名付きUserInfoエンドポイントのレスポンスに使用するJWAアルゴリズムを設定します。「unsigned」に設定した場合は、UserInfoレスポンスは署名されず、application/json形式で返されます。",
  "requestObjectSignatureAlgorithm": "クライアントが「request」または「request_uri」パラメーターで指定されたOIDCリクエスト・オブジェクトを送信する際に使用する必要がある、JWAアルゴリズムを設定します。「any」に設定した場合は、リクエスト・オブジェクトは任意のアルゴリズム（「none」を含む）で署名されます。",
  "requestObjectRequired": "クライアントが認可リクエストとともにリクエスト・オブジェクトを提供する必要があるかどうか、およびそのためにどの方法を使用できるかを指定します。「not required」に設定されている場合、リクエスト・オブジェクトの提供はオプションです。それ以外のケースでは、リクエスト・オブジェクトを提供する必要があります。「request」に設定されている場合、リクエスト・オブジェクトは値で提供される必要があります。「request_uri」に設定されている場合、リクエスト・オブジェクトは参照によって提供される必要があります。「requestまたはrequest_uri」に設定されている場合、いずれの方法も使用できます。",
  "idpInitiatedSsoUrlName": "IDP Initiated SSOを行う際にクライアントを参照するためのURLフラグメント名を設定します。空にするとIDP Initiated SSOは無効になります。ブラウザーから参照するURLは「{server-root}/realms/{realm}/protocol/saml/clients/{client-url-name}」になります。",
  "idpInitiatedSsoRelayState": "IDP Initiated SSOを行う際のSAMLリクエストで送信したいRelayStateを設定します。",
  "masterSamlProcessingUrl": "設定された場合は、このURLがSPのアサーション・コンシューマーおよびシングル・ログアウト・サービスの両方のBindingに使われます。これは、SAMLエンドポイントの詳細設定にある各Bindingやサービスの設定にて個別に上書きすることができます。",
  "excludeSessionStateFromAuthenticationResponse": "これがオンの場合、パラメーター「session_state」はOpenID Connect認証レスポンスに含まれません。クライアントが「session_state」パラメーターをサポートしていない古いOIDC / OAuth2アダプターを使用している場合に便利です。",
  "assertionLifespan": "SAMLアサーション条件に設定された有効期限。その後、アサーションは無効になります。「SessionNotOnOrAfter」属性は変更されず、レルムレベルで定義された「SSOセッション最大」時間を引き続き使用します。",
  "accessTokenLifespan": "アクセストークンが有効期限切れとなる最大時間です。この値はSSOタイムアウトと比べて短くすることをお勧めします。",
  "oAuthMutual": "これにより、OAuth 2.0相互TLS証明書バインド・アクセストークンがサポートされます。つまり、Keycloakは、Keycloakのトークン・エンドポイントとこのクライアントの間で相互TLSにより交換されるクライアントのX.509証明書と、アクセストークンおよびリフレッシュ・トークンをバインドします。これらのトークンは、ベアラートークンの代わりにHolder-of-Keyトークンとして扱うことができます。",
  "keyForCodeExchange": "PKCEのどのコードチャレンジ方式を使用するかを選択します。指定しない場合、Keycloakは、クライアントが適切なコードチャレンジとコード交換の方式で認可リクエストを送信しない限り、クライアントにPKCEを適用しません。",
  "assertionConsumerServicePostBindingURL": "アサーション・コンシューマー・サービス（ログイン・レスポンス）のSAML POSTバインディングURLを設定します。このBindingのためのURLがない場合は空でよいです。",
  "assertionConsumerServiceRedirectBindingURL": "アサーション・コンシューマー・サービス（ログイン・レスポンス）のSAML RedirectバインディングURLを設定します。このBindingのためのURLがない場合は空でよいです。",
  "logoutServicePostBindingURL": "シングル・ログアウト・サービスのSAMLPOSTバインディングURLを設定します。異なるBindingを使用している場合は空でよいです。",
  "logoutServiceRedirectBindingURL": "シングル・ログアウト・サービスのSAMLRedirectバインディングURLを設定します。異なるBindingを使用している場合は空でよいです。",
  "frontchannelLogout": "有効の場合は、ログアウトはクライアントへのブラウザー・リダイレクトが必要になります。無効の場合は、サーバーはログアウトのバックグラウンド呼び出しを行います。",
  "authenticationOverrides": "レルム認証フロー・バインディングをオーバーライドします。",
  "browserFlow": "ブラウザー認証で使用したいフローを選択してください。",
  "directGrant": "ダイレクト・グラント認証で使用したいフローを選択してください。",
  "certificate": "クライアントで発行され、キーストアの秘密鍵で署名されたJWTを検証するためのクライアント証明書です。",
  "jwksUrl": "JWK形式のクライアント鍵が格納されているURLを設定します。詳細はJWKの仕様を参照してください。「jwt」クレデンシャルを持つKeycloakクライアント・アダプターを使用している場合は、アプリケーションに「/k_jwks」という接尾辞を付けたURLを使用することができます。例えば、「http://www.myhost.com/myapp/k_jwks」です。",
  "archiveFormat": "JavaキーストアまたはPKCS12アーカイブ形式",
  "keyAlias": "秘密鍵と証明書のアーカイブ・エイリアスです。",
  "keyPassword": "アーカイブ内の秘密鍵にアクセスするためのパスワード",
  "storePassword": "アーカイブ自身にアクセスするためのパスワード",
  "consentRequired": "有効の場合は、ユーザーはクライアント・アクセスに同意する必要があります。",
  "import": "リソースサーバーの認可設定を含むJSONファイルをインポートします。",
  "policyEnforcementMode": "ポリシー施行モードは、認可リクエストを評価する際に適用される方法を決定します。「Enforcing」は、与えられたリソースに関連するポリシーが存在しない場合でも、リクエストはデフォルトで拒否されることを意味します。「Permissive」は、与えられたリソースに関連するポリシーが存在しない場合でも、リクエストは許可されることを意味します。「Disabled」は、完全にポリシーの評価を無効にし、任意のリソースへのアクセスを許可します。",
  "decisionStrategy": "決定戦略は、パーミッションの評価方法と最終的な判定の取得方法を決定します。「Affirmative」とは、リソースおよびそのスコープへのアクセスを許可するために、少なくとも1つのパーミッションが肯定的な判定に評価される必要があることを意味します。「Unanimous」とは、最終的な判定も肯定的であるために、すべてのパーミッションが肯定的な判定に評価される必要があることを意味します。",
  "allowRemoteResourceManagement": "リソースは、リソースサーバーによりリモートで管理すべきかどうかを設定します。オフの場合は、リソースはこの管理コンソールだけで管理されます。",
  "resourceName": "このリソースの一意な名前。この名前は、リソースを一意に識別するために使用でき、特定のリソースを照会するときに便利です。",
  "type": "このリソースのタイプを設定します。異なるリソース・インスタンスを同じタイプにグルーピングすることができます。",
  "uris": "リソースによって保護されているURIのセット。",
  "scopes": "このリソースに関連付けるスコープを設定します。",
  "fullScopeAllowed": "全ての制限の無効を許可します。",
  "ownerManagedAccess": "有効にすると、このリソースへのアクセスをリソースオーナーが管理できます。",
  "resourceAttribute": "リソースに関連付けられた属性。",
  "resetActions": "ユーザーにリセット・アクションEメールを送信するときに実行するアクションのセット。「Verify Email」は、Eメールアドレスを確認するためのEメールをユーザーに送信します。「Update Profile」は、新しい個人情報を入力する必要があります。「Update Password」は、ユーザーが新しいパスワードを入力する必要があります。「Configure OTP」は、モバイル・パスワード・ジェネレーターの設定が必要です。",
  "lifespan": "アクション許可が失効するまでの最大時間。",
  "scopeName": "このスコープのユニークな名前を設定します。名前はスコープの一意な識別に使用され、特定のスコープを照会する際に使用することができます。",
  "policy-name": "このポリシーの名前を設定します。",
  "policy-description": "このポリシーの説明を設定します。",
  "policyDecisionStagey": "決定戦略は、ポリシーの評価方法と最終的な判定方法を決定します。「Affirmative」は、最終判定がpositiveとなるためには、少なくとも1つのポリシーがpositiveと評価する必要がある、ということを意味します。「Unanimous」は、全体の判定がpositiveとなるためには、すべてのポリシーがpositiveと評価する必要がある、ということを意味します。「Consensus」は、positiveの数がnegativeの数より多くなければならないことを意味します。positiveとnegativeの数が同じ場合は、最終的な判定はnegativeになります。",
  "applyPolicy": "このポリシーやパーミッションで定義されたスコープに適用するすべてのポリシーを設定します。",
  "policyClient": "このポリシーで許可されるクライアントを指定します。",
  "groupsClaim": "定義されている場合、ポリシーは、パーミッションを要求するアイデンティティーを表すアクセストークンまたはIDトークン内の特定のクレームから、ユーザーのグループを取得します。定義されていない場合、ユーザーのグループはレルム設定から取得されます。",
  "policyGroups": "どのユーザーがこのポリシーで許可されるか指定してください。",
  "policyRoles": "このポリシーで許可されるクライアント・ロールを指定してください。",
  "startTime": "ポリシーを許可しない日時を定義します。現在日時がこの値より後か、等しい場合にのみ許可されます。",
  "expireTime": "ポリシーを許可しない日時を定義します。現在日時がこの値より前か、等しい場合にのみ許可されます。",
  "month": "ポリシーが許可される月を定義します。2番目のフィールドに値を入力して範囲を指定することもできます。この場合、現在の月が指定した2つの値の間にあるか、等しい場合のみ許可されます。",
  "dayMonth": "ポリシーが許可される日を定義します。2番目のフィールドに値を入力して範囲を指定することもできます。この場合、現在の日が指定した2つの値の間にあるか、等しい場合のみ許可されます。",
  "hour": "ポリシーが許可される時を定義します。2番目のフィールドに値を入力して範囲を指定することもできます。この場合、現在の時が指定した2つの値の間にあるか、等しい場合のみ許可されます。",
  "minute": "ポリシーが許可される分を定義します。2番目のフィールドに値を入力して範囲を指定することもできます。この場合、現在の分が指定した2つの値の間にあるか、等しい場合のみ許可されます。",
  "policyCode": "このポリシーに対する条件を提供するJavaScriptコード。",
  "logic": "ロジックは、ポリシーの判定方法を決定します。「Positive」の場合は、このポリシーの評価中に得られた結果（許可または拒否）が判定の実行に使用されます。「Negative」の場合は、結果は反転されます。つまり、許可は拒否になり、拒否は許可になります。",
  "permissionName": "このパーミッションの名前を設定します。",
  "permissionDescription": "このパーミッションの説明を設定します。",
  "permissionType": "このパーミッションが適用されるリソースタイプを指定します。",
  "permissionsEnabled": "このロールを管理するために、きめ細かいパーミッションを有効にするかどうかを決定します。無効にすると、設定されている現在のパーミッションがすべて削除されます。"
}