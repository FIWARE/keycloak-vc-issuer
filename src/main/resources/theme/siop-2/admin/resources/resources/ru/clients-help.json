{
  "clientType": "'OpenID connect' разрешает клиентам проверить личность конечного пользователя, основанного на  выполнении аутентификации на Сервере Авторизации.'SAML' включает веб-сценарии аутентификации и авторизации, включая кроссдоменные центры единого управления доступом (SSO) и использующие токены безопасности, содержащие заявления на передачу информации.",
  "serviceAccount": "Разрешает Вам аутентифицировать этого клиента в Keycloak и получить токен доступа специально для этого клиента. В терминах OAuth2 спецификации включает поддержку 'Client Credentials Grant' для этого клиента.",
  "authorization": "Включить/Выключить тонко-настраиваемую поддержку авторизации для клиента",
  "directAccess": "Включает поддержку Direct Access Grants, которая означает, что клиент имеет доступ к имени пользователя и пароля и обменивает их напрямую с сервером Keycloak на токен доступа. В терминах OAuth2 спецификации означает поддержку 'Resource Owner Password Credentials Grant' для этого клиента.",
  "standardFlow": "Включает стандартное OpenID Connect перенаправление, основанное на аутентификации с кодом авторизации. В терминах OpenID Connect или OAuth2 спецификаций включает 'Authorization Code Flow' для этого клиента.",
  "implicitFlow": "Включает поддержку OpenID Connect перенаправления, основанного на аутентификации без кода авторизации. В терминах OpenID Connect или OAuth2 спецификаций включает поддержку 'Implicit Flow' для этого клиента.",
  "rootURL": "Корневой URL добавляется к относительным URL",
  "validRedirectURIs": "Валидирует паттерн URI, на который может быть перенаправлен браузер после успешного входа или выхода. Разрешены простые ссылки, напр. 'http://example.com/*'. Также допускается использовать относительный путь, напр. '/my/relative/path/*'. Относительные пути необходимо указывать относительно корневого URL клиента, или, если он не специфицирован, корневого URL сервера авторизации. Для SAML Вы должны задать валидный паттерн URI, если Вы полагаетесь на URL сервиса потребителя, внедренного в запрос авторизации.",
  "nameIdFormat": "Наименование формата ID для использования в теме.",
  "forceNameIdFormat": "Игнорирует запрошенный формат заголовка NameID и использует сконфигурированный через консоль администратора.",
  "forcePostBinding": "Всегда использовать POST Binding для ответов.",
  "includeAuthnStatement": "Должны ли заявки на методы и временные метки быть включены в ответе на вход?",
  "includeOneTimeUseCondition": "Должно ли условие одноразового использования быть включено в ответе на вход?",
  "optimizeLookup": "При подписи SAML документов при REDIRECT сопоставлении с SP, который обеспечивается безопасностью адаптера Keycloak, должен ли включать ID подписанного ключа в сообщение по протоколу SAML в <Extensions> элемент? Это оптимизирует валидацию сигнатуры, где в качестве проверки используется один ключ вместо попытки проверки каждого ключа во время валидации.",
  "signDocuments": "Должны ли SAML документы быть подписаны в realm?",
  "signAssertions": "Должны ли утверждения внутри SAML документов быть подписаны? Устанавливает отсутствие необходимости подписывать уже подписанные документы.",
  "signatureAlgorithm": "Алгоритм, используемый для подписи документов.",
  "signatureKeyName": "Подписанные SAML документы содержат идентификаторы ключей подписи в элементе KeyName. Для Keycloak / RH-SSO контрагентов, используйте KEY_ID, для MS AD FS используйте CERT_SUBJECT, для остальных установите и используйте NONE если другие опции не работают.",
  "canonicalization": "Метод канонизации для XML сигнатур.",
  "webOrigins": "Разрешает CORS источникам. Чтобы разрешить всем источники с допустимыми URI-адресами переадресации, добавьте '+'. Чтобы разрешить все источники, добавьте '*'.",
  "homeURL": "Используемый URL по умолчанию. Используется в случае, если серверу требуется перенаправление или обратная ссылка на клиента.",
  "adminURL": "URL для доступа к интерфейсу администратора в заданном клиенте. Необходимо установить, если клиент поддерживает адаптер REST API. Это REST API разрешает серверу авторизации слать политики отзыва и прочие административные задачи. Обычно устанавливается значение, соответствующее базовому URL клиента.",
  "client": "Выберите клиента, осуществляющего авторизационный запрос. Если не задан, авторизационные запросы будут основаны на том клиенте, в котором вы находитесь.",
  "clientId": "Задает идентификатор, указываемый в URI и в токенах. Например 'my-client'. Для SAML это также ожидаемое имя издателя для запросов аутентификации",
  "selectUser": "Выберите пользователя, идентификационные данные которого будут использованы для запроса разрешений с сервера.",
  "roles": "Выберите роли, которые вы хотите связать с выбранным пользователем.",
  "contextualAttributes": "Любой аттрибут определяется запущенным окружением или контекстом исполнения.",
  "applyToResourceType": "Определяет, будет ли это разрешение будет применено ко всем ресурсам с данным типом. В этом случае это разрешение будет вычисляться для всех экземпляров с заданным типом ресурса.",
  "resources": "Определяет, что это разрешение должно быть применено к конкретному экземпляру ресурсов.",
  "scopesSelect": "Определяет, что разрешение должно быть применено к одной или нескольким областям.",
  "clientName": "Задает отображаемое название клиента. Например 'My Client'. Поддерживает ключи для локализованных значений. Например\\: ${my_client}",
  "description": "Задает описание клиента. Например 'Мой клиент для табеля учета времени'. Поддерживает ключи для локализованных значений. Например: ${my_client_description}",
  "loginTheme": "Выберите тему для страниц входа, временного одноразового пароля (OTP), выдачи разрешений, регистрации и восстановления пароля.",
  "encryptAssertions": "Должны ли SAML утверждения быть зашифрованы публичным ключом клиента, используя AES?",
  "clientSignature": "Будет ли клиент подписывать свои saml запросы и ответы? И должны ли они быть провалидированы?",
  "expiration": "Определяет, как долго токен будет оставаться валидным",
  "count": "Определяет, как много клиентов может быть создано с помощью этого токена",
  "client-authenticator-type": "Проверка подлинности клиента используется для аутентификации этого клиента вместо сервера Keycloak",
  "registration-access-token": "Токен доступа к регистрации обеспечивает доступ для клиентов к сервису регистрации клиентов.",
  "nodeReRegistrationTimeout": "Интервал, означающий максимальное время для узлов кластера зарегистрированных клиентов для их перерегистрации. Если узел кластера не может послать запрос перерегистрации в Keycloak за указанное время, то он будет разрегистрирован из Keycloak",
  "userInfoSignedResponseAlgorithm": "JWA алгоритм используется для подписи ответа ресурса информации о пользователе. Если установлено в 'unsigned', то ответ инофрмации о пользователе не будет подписан и будет возвращен в формате application/json.",
  "requestObjectSignatureAlgorithm": "JWA алгоритм, который необходим клиенту для использования во время отсылки OIDC запроса объекта, специфицированного по 'request' или 'request_uri' параметрам. Если установлено в 'any', то объект запроса будет подписан любым алгоритмом (включая 'none' ).",
  "idpInitiatedSsoUrlName": "Имя URL фрагмента, обозначающего клиента, если вы хотите, чтобы SSO был проинициирован поставщиком идентификации. Оставьте это поле пустым, чтобы отключить инициирование SSO с помощью поставщика идентификации. URL для ссылки вашего браузера может быть в следующем виде: {server-root}/realms/{realm}/protocol/saml/clients/{client-url-name}",
  "idpInitiatedSsoRelayState": "Передать состояние, которое вы хотите послать вместе с SAML запросом, которым хотите проиницировать SSO поставщиком идентификации.",
  "masterSamlProcessingUrl": "Если URL сконфигурирован, то он будет каждый раз для связывания SP's Assertion Consumer и Single Logout Services. Может быть переопределен индивидуально для связывания каждого сервиса в тонкой настройке конфигурации конечных точек доступа SAML.",
  "accessTokenLifespan": "Максимальное время действия токена доступа. Значение рекомендуется устанавливать как можно ближе к таймауту SSO.",
  "assertionConsumerServicePostBindingURL": "URL-адрес SAML POST запроса для клиентских сервисов подтверждения потребителей (запросы входа). Вы можете оставить это поле пустым, если не имеете URL для осуществления такой приввязки.",
  "assertionConsumerServiceRedirectBindingURL": "SAML переадресация на привязанный URL для клиентского сервиса подтверждения потребителей (запросы входа). Вы можете оставить это поле пустым, если вы не имеете URL для осуществления такой привязки.",
  "logoutServicePostBindingURL": "SAML POST связанный URL для клиентского сервиса единого выхода. Если Вы используете другие привязки, то можете оставить это поле пустым.",
  "logoutServiceRedirectBindingURL": "SAML переадресует на привязанный URL для единой точки выхода из сервиса для клиентов. Если Вы используете другие привязки, то можете остаавить это поле пустым.",
  "frontchannelLogout": "Когда правила, выход требует перенаправить браузер на клиента. Если ложь, сервер выполняет фоновый режим для выхода из системы.",
  "browserFlow": "Выберите сценарий, который вы хотите использовать для аутентификации через браузер.",
  "directGrant": "Выберите сценарий, который вы хотите использоваться для аутентификации direct grant.",
  "certificate": "Клиентский сертификат для валидации JWT, выпущенный клиентом и подписанный клиентским приватным ключом из Вашего хранилища ключей.",
  "jwksUrl": "URL, где клиентские ключи хранятся в формате JWK. Для дополнительных деталей смотрите спецификацию JWK. Если Вы будете использовать адаптер клиента keycloak с учетными записями \"jwt\", то Вы можете использовать URL вашего приложения с суффиксом '/k_jwks'. Например 'http://www.myhost.com/myapp/k_jwks' .",
  "archiveFormat": "Формат архивации Java keystore или PKCS12.",
  "keyAlias": "Синоним архива для Вашего приватного ключа и сертификата.",
  "keyPassword": "Пароль для доступа к приватного ключу в архиве",
  "storePassword": "Пароль для доступа в сам архив ",
  "consentRequired": "Если включено, пользователи должны дать согласие на доступ клиентскому приложению.",
  "import": "Импорт JSON файла, содержащего авторизационные настройки для этого сервера ресурсов.",
  "policyEnforcementMode": "Режим применения политик диктует, каким образом политики применяются при оценке запросов на авторизацию. «Обязывающая» означает, что запросы запрещены по умолчанию, даже если нет никакой политики, связанной с данным ресурсом. \"Разрешающая\" означает, что запросы разрешены даже если не существует политика, связанная с данным ресурсом. 'Отключено' полностью отключает оценку политики и позволяет получить доступ к любому ресурсу.",
  "allowRemoteResourceManagement": "Должны ли ресурсы управляться удаленно сервером ресурсов? Если нет, то ресурсы могут управляться только через консоль администратора. ",
  "resourceName": "Уникальное имя для этого ресурса. Имя может быть использовано для уникальной идентификации ресурса, используется при запросах конкретных ресурсов.",
  "type": "Тип этого ресурса. Может быть использовано для группировки различных экземпляров ресурса с тем же типом.",
  "uris": "URI, который также может быть использован для уникальной идентификации этого ресурса.",
  "scopes": "Области, ассоциироваанные с этим ресурсом.",
  "fullScopeAllowed": "Отключает все ограничения.",
  "resetActions": "Набор действия для выполнения при отправке пользователю письма с указаниями по сбросу пароля. 'Подтвердить E-mail' высылает пользователю письмо для подтверждения его E-mail. 'Обновить профиль' требует от пользователя ввести новую персональную информацию. 'Обновить пароль' требует от пользователя ввести новый пароль. 'Настроить OTP' требует установить мобильное приложение с генератором паролей.",
  "scopeName": "Уникальное имя для области. Имя может быть использовано для уникальной идентификации области, используется при запросах конкретных областей.",
  "policy-name": "Название этой политики.",
  "policy-description": "Описание этой политики.",
  "policyDecisionStagey": "Стратегия решения диктует как политики связаны с заданными разрешениями и как формируется окончательное решение. 'Утвердительная' означает, что, по крайней мере, одна политика должна дать положительную оценку для того, чтобы окончательное решение также было положительным. 'Единогласная' означает что все политики должны дать положительную оценку для того, чтобы окончательная оценка также была положительной. 'Консенсусная' означает, что количество положительных решений должно превышать количество отрицательных решений. Если количество положительных и отрицательных решений совпадает, окончательное решение будет отрицательным.",
  "applyPolicy": "Определяем все политики, которые должны быть применены к областям, определенным этой политикой или разрешением.",
  "policyClient": "Задайте, какие клиенты допущеный этой политикой.",
  "policyGroups": "Задайте, какие пользователи допущены этой политикой.",
  "policyRoles": "Задайте роли клиента, допущенные этой политикой.",
  "startTime": "Определете время, до наступления которого политика НЕ ДОЛЖНА быть разрешена. Разрешено только если текущее время/дата больше или равны заданному значению.",
  "expireTime": "Определяет время, после которого политика НЕ ДОЛЖНА быть разрешена. Разрешено только если текущее время/дата менеьше или равны заданному значению.",
  "month": "Определяет месяц, в который политика ДОЛЖНА быть разрешена. Вы также можете определить диапазон, заполнив второе поле. В этом случае разрешение выдается только если текущий месяц равен или находится между заданными значениями.",
  "dayMonth": "Определяет день месяца, в который политика ДОЛЖНА быть разрешена. Вы также можете определить диапазон, заполнив второе поле. В этом случае разрешение выдается только если текущий день месяца равен или находится между заданными значениями.",
  "hour": "Определяет час, в который политика ДОЛЖНА быть разрешена. Вы также можете определить диапазон, заполнив второе поле. В этом случае разрешение выдается только если текущий час равен или находится между заданными значениями.",
  "minute": "Определяет минуту, в которую политика ДОЛЖНА быть разрешена. Вы также можете определить диапазон, заполнив второе поле. В этом случае разрешение выдается только если текущая минута равна или находится между заданными значениями.",
  "policyCode": "Код JavaScript, предоставляющий условия для этой политики.",
  "logic": "Логика диктует, как политика должна применяться. Если 'Позитивная', результирующий эффект (разрешение или запрещение) полученный в ходе оценки этой политики будет использован для выполнения решения. Если 'Негативная', результирующий эффект будет отрицательным, другими словами, разрешение становится запрещением и наоборот.",
  "permissionName": "Имя этого разрешения.",
  "permissionDescription": "Описание этого разрешения.",
  "permissionType": "Определяет, что это разрешение должно быть применено ко всем экземплярам ресурсов заданного типа."
}